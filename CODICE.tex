In seguito riportiamo delle considerazioni sulle librerie che abbiamo implementato, per evidenziare le caratteristiche del codice e le scelte di design.
In particolare:
\begin{itemize}
	\item Setup
	\item PrintOnScreen
	\item CMT
	\item main
\end{itemize}

Abbiamo pensato di strutturare il codice come se fosse un modulo indipendente e importabile in un qualsiasi progetto.

Per questo motivo abbiamo semplificato il piú possibile, per rendelo utilizzabile con minime modifiche.

In piú abbiamo lo abbiamo reso tale da incapsulare tutte le sue funzionalitá, purché minimali, senza dover controllare il codice.
Poche chiamate e con nomi espressivi sulla funzione.

SETUP

Per rendere il piú facile possibile il riutilizzo del sistema di controllo AHRS, si é scelto di ridurre al minimo la complessitá delle chiamate.
A questo scopo, é stata creata una libreria \emph{Setup} la quale gestisce le inizializzazioni di tutti i sensori, dello schermo e routin di calibrazione del magnetometro.
In questo modo sará necessario solo importare le librerie necessarie e fare una sola chiamata alla funzione \textbf{Setup_MARG} e a \textbf{Read_MARG} ogni qual volta si vuole leggere i dati dai sensori, per usufruire del sistema.

Inoltre é stata eseguita la scelta di fornire come parametro di input alla funzioni, una istanza della struttura dati \textbf{AHRS_out}, la quale contiene tutti i dati relativi agli angoli e alle velocitá angolari, per facilitare la manipolazione dei dati di navigazione.
Infatti all’interno della funzione di setup, vengono chiamate le funzioni che si occupano di leggere i dati dai sensori, per poi aggiornare proprio la struttura dati del tipo \emph{AHRS_out}.
Quindi, é possibile, sempre da quella stessa istanza, ricavare i dati di navigazione, per esempio, per poter essere manipolati in segnali di controllo dei servo.

Ad ogni funzione, interna alla libreria, vengono passati i riferimenti ai puntatori della struttura dati che necessitano.

``` c
void Read_MARG(AHRS_out* ahrs)
{
	imu_read(&ahrs->raw, &ahrs->sens, &ahrs->temp);
	mag_read(&ahrs->mag);
	getYPR(&ahrs->mag, &ahrs->temp, &ahrs->ahrs_data);
}
```

PRINT

Sempre per lo stesso motivo di rendere il piú modulare possibile, si é diviso la funzione di stampa su schermo, poiché non é un comportamento utile, nel caso di utilizzo nel ducted fan.
Si considera la libreria \textbf{PrintOnScreen} uno strumento utile alla verifica dei dati e debug in caso di cambiamenti al sistema di calcolo delle coordinate.

Questa libreria non é affatto necessarria al fine del funzionamento del sistema di controllo AHRS, e non é richiesta da nessuna altra libreria; é un modulo a se stante, che integra la stampa.
Per questo, si puó liberamente omettere nell’importazione, a discrezione del progetto.

CMT

Si ha utilizzato la libreria \textbf{CMT}, fornita dalla Renesas negli esempi, e dataci dal gruppo precedente che ha lavorato al sistema che noi abbiamo raffinato.

Questa libreria permette di eseguire interrupt temporizzati.
Abbiamo utilizzato questa libreria per aggiornare i dati di lettura ad intervalli regolari.

Sappiamo che la scelta piú raffinata sarebbe stata implementare la lettura tramite interrupt generati dalla scheda GY-86, ma non sapevamo come sarebbe stato implementato nel suo complessivo il ducted fan.

Questa libreria é stata utilizzata solo a scopo esemplificativo e il funzionamento dell’AHRS non é vincolato al suo utilizzo.

MAIN

Il main, nel nostro caso, risulta molto minimale e ridotto, volutamente all’osso, poiché si é voluto assicurare la modularitá del sistema di controllo AHRS; serve solo a rappresentare le chiamate stettamente necessarie all’utilizzo in un progetto.

É stato necessario utilizzare la chiamata \emph{extern} alla dichiarazione della struct \emph{timerClocks}, poiché abbiamo scelto di non modificare in alcun modo la libreria \emph{CMT}.
Infatti, come giá menzionato, la libreria é stata fatta e distribuita dalla renesas e per evitare di eseguire modifiche in altre librerie che non siano direttamente collegate al sistema AHRS, abbiamo riutilizzato la struttura dati che viene dichiarata in quella libreria.
Per cui, sará necessario importare il CMT e dichiarare l’istanza di \emph{timerCloks} come extern senza dover fare nessuna altra modifica.

La frequenza con cui chiamare la funzione dipende dal sistema che si é optato di utilizzare.
Nel nostro caso abbiamo utilizzato la libreria \emph{CMT} con interrupt temporizzati.
L’importante é scegliere l’aggiornamento di lettura coerente con le caratteristiche del hardware a disposizione.

Per modificare la frequenza di lettura dei sensori si dovrá cercare l’opportuna variabile nelle librerie \emph{imu} e \emph{mag}.
Avremmo potuto rendere modificabile questi parametri direttamente in fase di setup, ma a nostro parere é una complicazione non necesarria, dato che nei rispettovo file, le variabili sono ben visibili, non salverebbe comunque dalla compliazione ed é una scelta che viene fatta una tantum in base alle specifiche del progetto.

Lo stesso vale per la stampa dei dati su schermo.
Dato il tempo di aggiornamento dei cristalli é sconsigliato stampare su schermo integrato piú di ogni decimo di secondo.
